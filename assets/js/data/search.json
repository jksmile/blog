[ { "title": "风控系统架构演进", "url": "/posts/page_70000/", "categories": "风控", "tags": "风控, 架构", "date": "2022-10-31 12:00:00 +0800", "snippet": "如何拿到目标offer？ 1.说在前面的话 2.准备工作 3.实行计划 4.面试技巧 5.总结 1.说在前面的话一年一度的毕业季又要到了，有朋友、亲戚家孩子即将要就业了，时常有电话、微信联系我，问以下两问题：问题1： 我家孩子学的生物|化学... 能做你现在做的工作吗？问题2： 我家孩子学计算机的，怎么找一个好公司就业？对于以上两个问题，问题1是我经历过多次，反思最深的话题，不过今天晚上时间有限，我打算找个更合适的时间来谈问题1.问题2是我今天要写这篇文章来解答的，即对科班出身的毕业生或者已经有IT工作经验的人，如何拿到..." }, { "title": "浅谈合格的技术面试官", "url": "/posts/page_90002/", "categories": "总结, 学习成长", "tags": "总结, 面试, 成长", "date": "2021-05-14 12:00:00 +0800", "snippet": "浅谈合格的技术面试官1.说在前面的话职场生涯来来往往，作为职场中的一名候选人，同时也担任过面试官角色的我，今天想聊聊我对如何成为一名合格面试官这个话题的个人见解。担任面试官拥有候选人的“生杀大权”，这背后更多的是一份沉甸甸的责任，同时面试不仅仅是面试候选人，也是面试官专业素质的体现，更是公司对外的一扇窗。在我作为面试官的经历中，担任过一面、二面、三面，在找到很多优秀队友的背后不乏很多失败的面试经历，总结下一路走来的心理活动及思考。1.我怎么去发现对方的不足？2.我怎么去问一些有水平的问题？3.在我的领域中，候选人不懂，他就不合格？4.候选人的领域我不懂，我怎么去沟通？5.面试结束后为什么..." }, { "title": "Log-Studio工程思考与实践", "url": "/posts/page_80000/", "categories": "总结, 工程实践", "tags": "日志, 日志组件", "date": "2021-04-12 15:00:00 +0800", "snippet": "1.背景现状►► 近些年随着容器化的普及应用，架构体系从微服务、云原生步步升级，工程日志不再是简简单单的纠查排错运维。更多的是承载着Logging、Tracing、Metrics、Topology等方面的任务。经过大量的工程实践，以ELK为代表的日志处理方案几乎完美地整合了日志抓取、搜索和展示几个方面的需求，是目前业界最流行的日志处理解决方案。在诸多工程项目应用中，在数据处理环境，主要是针对日志date、level、traceId等头部通用数据的提取，对于message部分的转换处理，通常将其作为整段处理或者针对不同项目情况做特定的pattern进行解析，最终将数据扔给ES去进行检索。►..." }, { "title": "如何拿到目标offer？", "url": "/posts/page_90000/", "categories": "总结, 技术面试", "tags": "总结, 技术面试", "date": "2016-07-09 23:02:00 +0800", "snippet": "如何拿到目标offer？ 1.说在前面的话 2.准备工作 3.实行计划 4.面试技巧 5.总结 1.说在前面的话一年一度的毕业季又要到了，有朋友、亲戚家孩子即将要就业了，时常有电话、微信联系我，问以下两问题：问题1： 我家孩子学的生物|化学... 能做你现在做的工作吗？问题2： 我家孩子学计算机的，怎么找一个好公司就业？对于以上两个问题，问题1是我经历过多次，反思最深的话题，不过今天晚上时间有限，我打算找个更合适的时间来谈问题1.问题2是我今天要写这篇文章来解答的，即对科班出身的毕业生或者已经有IT工作经验的人，如何拿到..." }, { "title": "优秀的Coder如何避开坑？", "url": "/posts/page_90001/", "categories": "总结, 学习成长", "tags": "总结, 转载", "date": "2016-03-10 12:00:00 +0800", "snippet": "优秀的Coder如何避开坑？转载微信：程序视界【programmer_sight】 前言 1.习惯即刻回报 2.缺乏学习热情 3.不够努力 4.畏难 5.缺乏责任心 6.消极，抱怨 7.没有时间管理观念 8.为薪水工作 9.其实不喜欢开发前言程序员薪水有高有低，有的人一个月可能拿30K、50K，有的人可能只有2K、3K。同样有五年工作经验的程序员，可能一个人每月拿20K，一个拿5K。是什么因素导致了这种差异？我特意总结了容易导致薪水低的九大行为表现，避开这些大坑，你就离高薪不远了。1.习惯即刻回报他不懂得只有春天播种，秋天才会有收获。刚刚付出一点点，甚至还没有付出，就..." }, { "title": "【行为型】中介者模式详解", "url": "/posts/page_30023/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-24 10:18:00 +0800", "snippet": "【行为型】中介者模式 定义 UML图 代码 应用定义定义：用一个中介者对象来封装一系列的对象交互。中介者模式中角色： 1.中介者接口(MediatorAbstract): 中介者接口。在里面定义了各个同事之间相互交互所需要的方法，可以是公共的方法，如Change方法，也可以是小范围的交互方法 2.具体中介者(ConcreteMediator): 具体的中介者实现对象。它需要了解并为维护每个同事对象，并负责具体的协调各个同事对象的交互关系 3.抽象同事类(Colleague): 同事类的定义，通常实现成为抽象类，主要负责约束同事对象的类型，并实现一些具体同事类之间..." }, { "title": "【行为型】访问者模式详解", "url": "/posts/page_30022/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-23 23:51:00 +0800", "snippet": "【行为型】访问者模式 定义 UML图 代码 应用定义定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式中角色： 1.抽象访问者类(VisitorAbstract): 为ConcreteElement的每一个类声明一个visit操作 2.具体访问者(ConcreteVisitor): 实现抽象访问者类声明的操作 3.抽象元素类(ElementAbstract): 声明一个接受的操作，参数为一个访问者 4.具体元素类(ConcreteElement): 具体的元素类实现抽象类的声明操作 ..." }, { "title": "【行为型】状态模式详解", "url": "/posts/page_30021/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-22 13:14:00 +0800", "snippet": "【行为型】状态模式 定义 UML图 代码 应用定义定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。命令模式中角色： 1.抽象状态类(AbstractState): 将具体状态类行为定义一个抽象方法 2.具体状态类(ConcreteState): 继续抽象状态类，实现具体的行为 3.容器类(Context): 存储具体状态类UML图 _ _ _ _ _ _ _ _ _ _ _ _ _| | | || Context |---→| AbstractState ||_ _ _ _..." }, { "title": "【行为型】备忘录模式详解", "url": "/posts/page_30020/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-21 21:49:00 +0800", "snippet": "【行为型】备忘录模式 定义 UML图 代码 应用定义定义：在不破坏封闭性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以将该对象恢复至保存时的状态。命令模式中角色： 1.发起人角色(Originator):负责创建一个备忘录,用以记录当前时刻它的内部状态，并可以使用备忘录恢复内部状态。发起人可以根据需要决定备忘录存储哪些内部状态 2.备忘录角色(Memento):负责存储Originator的内部状态，并可防止Originator以外的对象访问备忘录 3.管理者角色(Caretaker):负责保存好备忘录Memento，不能对备忘录的内容进..." }, { "title": "【行为型】命令模式详解", "url": "/posts/page_30019/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-20 22:54:00 +0800", "snippet": "【行为型】命令模式 定义 UML图 代码 应用定义定义：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。命令模式中角色： 1.抽象命令角色(AbstractCommand):将共同执行的命令方法进行抽象 2.具体命令角色(ConcreteCommand):对抽象类中的方法进行实现 3.处理事务角色(Receiver):负责接收命令，并执行命令 4.调用命令角色(Invoker):负责调用命令命令模式优点： 1.封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调..." }, { "title": "【行为型】责任链模式详解", "url": "/posts/page_30018/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-19 07:19:00 +0800", "snippet": "【行为型】责任链模式 定义 UML图 代码 应用定义定义：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。UML图 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | | | | | client |---→| AbstractHandler |←---┐ |_ _ _ _ _ _| | requestHandler() | | |_ _ _ _ _..." }, { "title": "【行为型】迭代器模式详解", "url": "/posts/page_30017/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-18 20:11:00 +0800", "snippet": "【行为型】迭代器模式 定义 UML图 代码 应用定义定义：提供一种方法有顺序的访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。迭代器模式中的角色：1.抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。2.具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set 接口的哈希列表的实现HashSet等。3.抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素 ..." }, { "title": "【行为型】观察者模式详解", "url": "/posts/page_30016/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-17 01:07:00 +0800", "snippet": "【行为型】观察者模式 定义 UML图 代码 应用定义定义：定义一种一对多的依赖关系，让多个观察者对象同时监听某一对象。这个主题对象在状态发生变化时，会通知所有观察 者对象，使它们能做出相应的动作。模板方法模式角色：UML图 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | | | | | AbstractSubject |---→| AbstractObserver | |_ _ _ _ _ _ _ _ _ _| |_ _ _ _ _ ..." }, { "title": "【行为型】模板方法模式详解", "url": "/posts/page_30015/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-16 23:31:00 +0800", "snippet": "【行为型】模板方法模式 定义 UML图 代码 应用定义定义：基类定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。模板方法模式角色：1.抽象类：实现模板方法，定义算法骨架2.具体类：实现抽象类中的抽象方法UML图 _ _ _ _ _ _ _ _ _ _ _ _ | | | TemplateAbstractClass | |_ _ _ _ _ _ _ _ _ _ _ _| ..." }, { "title": "【行为型】策略模式详解", "url": "/posts/page_30014/", "categories": "设计模式", "tags": "行为型, 设计模式", "date": "2013-04-15 23:31:00 +0800", "snippet": "【行为型】策略模式 定义 UML图 代码 应用定义定义：定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。策略模式优点：1.相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能2.提供了可以替换继承关系的办法3.消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许..." }, { "title": "【结构型】享元模式详解", "url": "/posts/page_30013/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-14 13:01:00 +0800", "snippet": "【结构型】享元模式 定义 UML图 代码 应用定义定义：利用共享技术有效地支持大量细粒度的对象。在了解享元模式之前我们先要了解两个概念：内部状态：在享元对象内部不随外界环境改变而改变的共享部分。外部状态：随着环境的改变而改变，不能够共享的状态就是外部状态。享元模式中的角色：抽象享元类：所有具体享元类的超类或者接口，通过这个接口，Flyweight可以作用于外部具体享元类：指定内部状态，为内部状态增加存储空间非共享具体享元类：指出不需要共享的Flyweight子类享元工厂类：用来创业并管理Flyweight对象，确保合理地共享Flyweight,当Client请求一个Flyweig..." }, { "title": "【结构型】组合模式详解", "url": "/posts/page_30012/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-13 23:42:00 +0800", "snippet": "【结构型】组合模式 定义 UML图 代码 应用定义定义：将对象组合成树形结构以表示‘部分-整体’的 层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。代理模式几个角色： 1.抽象构件角色：组合中对象声明接口，在适当情况下，实现所有类共有的默认行为。声明一个接口用于访问和管理子部件 2.树叶构件角色：在组合树中表示叶节点对象，叶节点没有子节点 3.树枝构件角色：定义有子部件的那些部件的行为。存储子部件，在抽象构件角色中实现与子部件有关的操作UML图 _ _ _ _ _ _ _ _ _ _ | | | ..." }, { "title": "【结构型】桥接模式详解", "url": "/posts/page_30011/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-12 06:22:00 +0800", "snippet": "【结构型】桥接模式 定义 UML图 代码 应用定义定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。代理模式几个角色： 1.变化因素接口类： 将可变的因素抽象成接口，各因素来实现接口 2.变化因素实现类： 实现变化因素接口 3.桥接抽象类：与变化因素接口 4.扩展桥接类：实现具体的业务外观模式优点： 1.能对不同的变化因素进行分类管理 2.实现对不同变化实现类解耦UML图 _ _ _ _ _ | | | Client | |_ _ _ _ _| | | | _ _ ↓_ _ __ ..." }, { "title": "【结构型】外观模式详解", "url": "/posts/page_30010/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-11 22:14:00 +0800", "snippet": "【结构型】外观模式 定义 UML图 代码 应用定义定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。代理模式几个角色： 1.外观角色：外观角色被客户端调用，它知道各个子系统的功能，可以根据客户端请求定制不同子系统的功能组合 2.子系统角色：实现子系统的任务，并处理由外观对象触发的任务外观模式优点： 1.外观模式对客户端屏蔽子系统组件，减少客户端调用子系统对象数目，外观模式使客户端调用变得简单 2.实现子系统组件与客户端松耦合，子系统组件的改变不影响客户端的调用，只需要调整外观类 3.提供了一个..." }, { "title": "【结构型】代理模式详解", "url": "/posts/page_30009/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-10 21:42:00 +0800", "snippet": "【结构型】代理模式 定义 UML图 代码 应用定义定义：为其他对象提供一种代理以控制对这个对象的访问。代理模式几个角色： 1.主题接口：提取真正使用类与代理类的公共方法 2.真正主题：真正处理请求的类 3.代理类：真正主题的代理类UML图 _ _ _ _ _ _ _ | | | Interface | |_ _ _ _ _ _ _| ↑ ..." }, { "title": "【结构型】装饰器模式详解", "url": "/posts/page_30008/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-09 20:39:00 +0800", "snippet": "【结构型】装饰器模式 定义 UML图 代码 应用定义定义：动态地给一个对象添加一些额外的职责或者行为。就增加功能来说， Decorator模式相比生成子类更为灵活。装饰器模式的组成： 1.抽象组件角色(Component):定义一个对象接口，以规范准备接受附加责任的对象，即可以给这些对象动态地添加职责 2.具体组件角色(ConcreteComponent):被装饰者，定义一个将要被装饰增加功能的类可以给这个类的对象添加一些职责 3.抽象装饰器(Decorator):维持一个指向构件Component对象的实例，并定义一个与抽象组件角色接口一致的接口 4.具..." }, { "title": "【结构型】适配器模式详解", "url": "/posts/page_30007/", "categories": "设计模式", "tags": "结构型, 设计模式", "date": "2013-04-08 20:39:00 +0800", "snippet": "【结构型】适配器模式 定义 UML图 代码 应用定义定义：将一个类的接口转换成需要的接口，使原本由于接口不兼容不能一起工作的类可以一起工作。适配器接口的几个角色： 1.目标接口(TargetInterface)：Client端所期待的接口【可以是具体的类、抽象类、接口】； 2.适配类(ServerAPI)：需要适配的类【Server端提供的原接口】； 3.适配器(AdapterInterface)：将适配类包装成目标接口的类；引用《大话设计模式》言语： 1.适配器模式有点亡羊补牢的意思； 2.适配器模式在某个阶段可能是最经济的做法；UML图 _ _..." }, { "title": "【创建型】原型模式详解", "url": "/posts/page_30006/", "categories": "设计模式", "tags": "创建型, 设计模式", "date": "2013-04-07 22:03:00 +0800", "snippet": "【创建型】原型模式 定义 UML图 代码 应用定义定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式主要用于对象的复制，它的核心是就是原型类，原型类需要具备以下条件： 1.实现Cloneable接口，否则会使用clone方法会抛出CloneNotSupportedException异常； 2.重写clone方法，将接口中的protect类型改为public类型；原型模式的优点： 1.使用原型模式创建对象比new一个对象在性能上要好很多，因为它直接操作内存中二进制流； 2.使用起来更为方便便捷；注意事项： 1.原型模式不会调..." }, { "title": "【创建型】建造者模式详解", "url": "/posts/page_30005/", "categories": "设计模式", "tags": "创建型, 设计模式", "date": "2013-04-06 12:09:00 +0800", "snippet": "【创建型】建造者模式 定义 UML图 代码 应用定义定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式的四个要点： 1.产品类，产品类可以是具体的类，也可以是抽象类与其实现类组成； 2.抽象建造者，可以是个抽象类或者接口，一般有创建产品方法和返回产品方法； 3.建造者，实现抽象建造者； 4.导演类，调用建造者来得到具体产品；建造者模式优点： 1.建造者模式可以有效的封装变化，将业务逻辑封闭在导演类中，整体稳定性好； 2.扩展性好，有新的需求，加入新的建造者即可；UML图 _ _ _ _ _ _ ..." }, { "title": "【创建型】抽象工厂模式详解", "url": "/posts/page_30004/", "categories": "设计模式", "tags": "创建型, 设计模式", "date": "2013-04-06 12:09:00 +0800", "snippet": "【创建型】抽象工厂模式 定义 UML图 代码 应用定义定义：多个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类；每个具体工厂类可创建多个具体产品类的实例。工厂方法模式是简单工厂模式的升级版抽象工厂模式有四个要素： 1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 2.这个系统有多于一个的产品族，而系统只消费其中某一产品族。 3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。 4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实..." }, { "title": "【创建型】工厂方法模式详解", "url": "/posts/page_30003/", "categories": "设计模式", "tags": "创建型, 设计模式", "date": "2013-04-05 22:38:00 +0800", "snippet": "【创建型】工厂方法模式 定义 UML图 代码 应用定义定义：一抽象产品类派生出多个具体产品类；一抽象工厂类派生出多个具体工厂类；每个具体工厂类只能创建一个具体产品类的实例。工厂方法模式是简单工厂模式的升级版工厂方法模式有四个要素： 1.产品接口，产品接口里定义产品的相关动作，产品接口里的定义直接决定代码的稳定性; 2.产品实现，产品实现决定了产品的具体的动作； 3.工厂接口，工厂接口是工厂方法的核心，它与调用方直接耦合来调用产品实现； 3.工厂实现，工厂实现负责如何实例化产品类，每个具体工厂实例化一具体产品类；UML图 _ _ _ _ _ _ ..." }, { "title": "【创建型】简单工厂模式详解", "url": "/posts/page_30002/", "categories": "设计模式", "tags": "创建型, 设计模式", "date": "2013-04-04 22:49:00 +0800", "snippet": "【创建型】简单工厂模式 定义 代码 应用定义简单工厂类又称为静态工厂类简单工厂模式根据提供给的不同数据，返回不两只类的实例，但这些类有一个共同的父类。简单工厂模式有三个要素： 1.产品接口。产品接口里定义产品的相关动作，产品接口里的定义直接决定代码的稳定性; 2.产品实现。产品实现决定了产品的具体的动作； 3.工厂类。通过传入工厂类的表态方法来决定实现化相关的产品实现；简单工厂模式的优点； 1.工厂的作用是实例化类，调用方不需要知道调用的具体子类，降低耦合；简单工厂模式的缺点； 1.新增加实例类型需要修改工厂，总之工厂需要知道要实例的类； 2.当..." }, { "title": "【创建型】单例模式详解", "url": "/posts/page_30001/", "categories": "设计模式", "tags": "创建型, 设计模式", "date": "2013-04-03 14:03:00 +0800", "snippet": "【创建型】单例模式详解 定义 代码 应用定义定义：单例模式就是在应用程序中，一个类只有一个实例的存在。单例模式的要点有三个； 1.某个类只能有一个实例； 2.它必须自行创建这个实例； 3.它必须自行向整个系统提供这个实例。有很多应用程序中都有单例模式的应用，比如数据库连接【稍后分析】。单例类既可以被状态化，也可以无状态化。同时单例模式有利于内存回收。在Spring框架中，单例类隐身可见。代码懒汉类型的单例模式public class Singleton{ //私有化构造方法 private Singleton(){ } private static Sing..." }, { "title": "设计模式原则", "url": "/posts/page_30000/", "categories": "设计模式", "tags": "定义, 设计模式", "date": "2013-04-02 23:23:00 +0800", "snippet": "设计模式原则 1.单一职责原则 2.里氏替换原则 3.依赖倒置原则 4.接口隔离原则 5.迪米特法则 6.开闭原则1.单一职责原则单一职责原则简称SRP【Single Responsibility Principle】,设计模式最基本原则。简单的说就是一个类只负责一件事，只有一个因素能引起类的变化。我们可以理解为类的专注吧，只有专注于解决某一件事才能专业。如果一个类负责多件事，这会千万类之间的耦合性高，不方便代码的扩展。2.里氏替换原则里氏替换原则简称LSP【Liskov Substitution Principle】是个什么鬼？名字叫的这么洋气！先来看下里氏替换原则的定义：..." }, { "title": "【算法解忧】零后置，保持数字相对排序", "url": "/posts/page_21007/", "categories": "算法", "tags": "算法", "date": "2013-02-17 20:30:00 +0800", "snippet": "零后置，保持数字相对排序So easy的问题都想不明白了，看来是要生锈的节奏！有个问题如下：现在有一个整型数组 [1,4,0,8,5,0,0,3] 写个function将输出: [1,4,8,5,3,0,0,0]将所有的0后置，结果保持相关数的相对顺序。Note:不可创建新数组；最小操作数组；怎么玩？突然觉得应该有个待定指针的想法。分析下：1 4 0 8 5 0 0 3A. 找到第一个0，在循环此数组时，第三次循环即可找到0.记录此时的下标为point.【第3次循环期望结果】1 4 0 8 5 0 0 3 ↑ pointB. 继续循环，碰到非零的数，就将数填充到point处，然..." }, { "title": "【算法解忧】数组中是否有两数之和等于目标值", "url": "/posts/page_21006/", "categories": "算法", "tags": "算法", "date": "2013-02-14 20:30:00 +0800", "snippet": "数组中是否有两数之和等于目标值Source Url:原文链接Given an array of integers, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answ..." }, { "title": "【算法解忧】最大子序列和的三种算法", "url": "/posts/page_21005/", "categories": "算法", "tags": "算法", "date": "2013-02-12 20:30:00 +0800", "snippet": "最大子序列和的三种算法 算法一 分析 代码 时间复杂度 算法二 分析 代码 时间复杂度 算法三 分析 代码 时间复杂度 ●算法一○分析示例序列X： 【1,-8,2,-1,5,-4,-3,4】计算序列X中最大子序列的和，通过钛合金狗眼扫描序列X最大子序列Y为【2,-1,5】如何找到序列Y的？最笨的方法莫过于两层循环对比○代码public class MaxSubSequenceSum{ public static int maxSu..." }, { "title": "【算法解忧】判断两二叉树是否相同", "url": "/posts/page_21004/", "categories": "算法", "tags": "算法", "date": "2013-02-11 20:30:00 +0800", "snippet": "判断两二叉树是否相同如何判断两二叉树对等？二叉树遍历，然后递归，想到的大概思路就是这样的，但改来改去，感觉码的砖老不简洁一定有更简洁的，最后终果不其然，真有最简洁的….Codepublic class TreeNode{ private int val; private TreeNode left; private TreeNode right;}public class Demo{ public boolean isSameTree(TreeNode x, TreeNode y){ if(x != null &a..." }, { "title": "【算法解忧】智者夺魁游戏", "url": "/posts/page_21003/", "categories": "算法", "tags": "算法", "date": "2013-02-10 20:30:00 +0800", "snippet": "智者夺魁游戏有个很有趣的游戏，我们称为智者夺魁游戏，游戏玩法如下：桌上有N个弹珠，每次只能从中拿出1到3个弹珠，最后拿完桌上弹珠的人获胜现在有如下问题：现在有A、B两同学，A同学先开始从一堆弹珠中拿，如果希望A获胜，则弹珠个数N是满足什么条件？这个问题，我们不妨来分类讨论下：CASE1. 假设桌上有N个弹珠（N&amp;lt;4），A先拿，A肯定全拿完，无论如何都是A胜出（别跟我说A会手下留情）；CASE2. 假设桌上有N个弹珠（N=4），A先拿，A无论怎么拿都会留机会给B，让B胜出；CASE3. 假设桌上有N个弹珠（4&amp;lt;N&amp;lt;8）,A先拿，A想胜出，必然..." }, { "title": "【算法解忧】求二叉树各路径结点之和并找出最大值的路径", "url": "/posts/page_21002/", "categories": "算法", "tags": "算法", "date": "2013-02-09 20:30:00 +0800", "snippet": "求二叉树各路径结点之和并找出最大值的路径最近没事将大学里的《数据结构》（严蔚敏，吴伟民著）一书重拾温习，受益颇多，才发现工作之中诸多经验问题都找到了理论支撑。当时觉得没用的书，现在只能嘲笑当时得多low… 现在依然很low… －－！事件背景因实际工作中，遇到一个关于权重的问题，需要将数据关系中最大权重的路径找到，然后就想到了《数据结构》中的dfs…此事勾起了我码砖的激情,让我本已平静的心再次荡漾…为了简单说明这个问题，我就拿个二叉树的模型来叙述一下我要达成的目标Case 1 / \\ 2 3 /\\4 5如图所见，一个二叉树，各结点值是int类型，现在要找出各结点之和最大的..." }, { "title": "【算法解忧】二叉树深度计算", "url": "/posts/page_21001/", "categories": "算法", "tags": "算法", "date": "2013-02-08 20:30:00 +0800", "snippet": "二叉树深度计算最近没事就跟树杠上了，虽然不知道在实际使用中会以什么样的形式应用，但还是蛮有兴趣的去耍耍.朋友去面试一公司，说问了一堆关于树的问题，其中有一个问题如下：问：写一个快速的算法去求一个二叉树的深度。For example:如下二叉树，深度为3. 1 / \\ 2 3 /\\4 5Tips: 递归遍历树； 从叶子结点到根结点；Code public class TreeNode{ private int val; private TreeNode right; private TreeNode left; }public..." }, { "title": "【算法解忧】分解相加返回一位数", "url": "/posts/page_21000/", "categories": "算法", "tags": "算法", "date": "2013-02-07 20:30:00 +0800", "snippet": "分解相加返回一位数最小的往往受到欺负… 现在要写个function让规则如下：一个非负int值，将此值各位数相加，如果结果小于两位数就返回，否则游戏继续。For example:给一个数：77 —&amp;gt; 7+7=14 &amp;gt;10 —&amp;gt; 1+4 =5 &amp;lt;10 —&amp;gt; return 5Tips: 首先想到的就是递归…Codepublic class Demo{ public int addDigits(int num){ if(num &amp;lt; 10) return ..." }, { "title": "排序算法", "url": "/posts/page_index/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": " 【选择排序】直接选择排序 【选择排序】堆排序 【交换排序】冒泡排序 【交换排序】快速排序 【插入排序】直接插入排序 【分配排序】基数排序 " }, { "title": "【分配排序】基数排序", "url": "/posts/page_20007/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": "【分配排序】基数排序 前言 思想 Code 前言Waiting for update...思想示例数组A| 12 | 8 | 132 | 29 | 76 | 48 | 7 |计算出数组A中最大元素a，确定最大元素长度n建立一个长度为10的数组X，数组中的元素是同样是一个数组，如果数组A中元素个位数字x,则将元素放入数组X中的x位置| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | ↓ ↓ ↓ ↓ ↓ 12 76 7..." }, { "title": "【插入排序】直接插入排序", "url": "/posts/page_20006/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": "【插入排序】直接插入排序 前言 插排思想 Code 快排思想插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕比如，以下是未排序的数组：| 4 | 3 | 5 | 1 | 2 |先拿出第二个数【下标为1】 与 第一个数【下标为0】的数进行对比，如果第一个数大于第二个数，则需要将第二个数临时存储，将第一个数后移，然后将临时存储的数【原第二个数】插入前面的位置i = 1;| 4 | | 5 | 1 | 2 | int temp = arr[1];| | 4 | 5 | 1 | 2 | arr[i] ..." }, { "title": "【交换排序】快速排序", "url": "/posts/page_20005/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": "【交换排序】快速排序 前言 快排思想 Code 前言平常码砖的时候，对于一个数组进行排序更多的是起泡排序，起泡排序对于一般不是很长的数组进行操作没什么问题，一旦数组过大，很明显效率低。而快排是对起泡排序的一种改进，效率明显优高。快排思想快排的思想是通过每一次排序将待排的数组分成两部分，左边的部分所有值均小于右边部分，然后再对这两部分分别再进行排序以达到整修序列有序。Example有如下一个无序的序列 arr[]（长度为10)，现在要对其进行快排| 10 | 9 | 22 | 38 | 47 | 7 | 11 | 2 | 82 | 1 |1.首先要先..." }, { "title": "【交换排序】冒泡排序", "url": "/posts/page_20004/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": "【交换排序】冒泡排序 前言 冒泡思想 Code 前言如果一个数组中，只有一两个是无序的，冒泡排序比较适合冒泡思想算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。比如，以下是未排序的数组：| 4 | 3 | 5 | 1 | 2 |经过第一轮对比排序：| 3 | 4 | 5..." }, { "title": "【选择排序】堆排序", "url": "/posts/page_20003/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": "【选择排序】堆排序 前言 思想 Code 前言Waiting for update...思想原数组arr如下：存储结构：| 8 | 3 | 6 | 4 | 1 | 2 | 5 | 7 |逻辑结构： 8 / \\ 3 6 / \\ / \\ 4 1 2 5 / 71.首先将原数据建成一个 大顶堆（大顶堆表示每个非叶子节点值大于其子节点值）,从最后一个非叶子节点开始进行,将大于父节点值的且是子节点中最大的子节点与父节点互换arr[3]在逻辑结构中为最后一个非叶子节..." }, { "title": "【选择排序】直接选择排序", "url": "/posts/page_20002/", "categories": "算法", "tags": "算法, 排序", "date": "2012-11-18 15:30:00 +0800", "snippet": "【选择排序】直接选择排序 前言 思想 Code 前言Waiting for update...思想比如，以下是未排序的数组：| 4 | 3 | 5 | 1 | 2 |经过第1轮选择，找出最小值，放第1位int temp = arr[0]arr[1] &amp;lt; temp -&amp;gt; temp = arr[1]| 4 | 3 | 5 | 1 | 2 | ↑ ↑arr[2] &amp;gt; temp -&amp;gt; temp| 4 | 3 | 5 | 1 | 2 | ↑arr[3] &amp;lt; temp..." }, { "title": "图的最短路径", "url": "/posts/page_20001/", "categories": "算法", "tags": "算法, 算法分析, 图", "date": "2012-11-12 21:42:00 +0800", "snippet": "图的最短路径 前言 某个源点到其余各顶点最短路径 一对顶点之间最短路径 前言在《数据结构》（严蔚敏&amp;amp;吴伟民）一书中花了一章节的内容来介绍图在图的遍历一节中介绍了两种遍历方法：DFS、WFS本篇内容主要介绍WFS的应用public class Dijkstra { private static final int MAX = 1024; private static final int MATRIX_LEN= 12; private static int[] dist = new int[MATRIX_LEN]; ..." }, { "title": "如何进行算法分析？", "url": "/posts/page_20000/", "categories": "算法", "tags": "算法, 算法分析, 时间复杂度", "date": "2012-11-07 20:11:00 +0800", "snippet": "如何进行算法分析？ 1.前言 2.数学基础 3.时间复杂度定义 5.实践分析 1.前言前几天在一篇微信公众号【算法与数据结构】上看到一篇关于算法时间复杂度分析基础的文章，写的比较基础但却不通透。所以我决定把大学的的老东西翻一翻，整理一篇自我感觉基础通透的知识点。2.数学基础我们常常说哪种算法好，说的是对于大量数据计算时算法的相对增长率较小，直白的说就是在最短时间内给出结果。对于相对增长率，我们由小到大列一些常见的数学函数：A. 对数函数 logN 【未声明的话，以2为底】B. 幂函数 N^2、N^3、N^4…C. 指数函数 2^N..." }, { "title": "什么是数据结构？", "url": "/posts/page_10000/", "categories": "数据结构", "tags": "定义, 数据结构", "date": "2012-11-06 23:10:00 +0800", "snippet": "什么是数据结构 说在前面的话 数据结构定义 基本结构说在前面的话大学读的是信息与计算科学专业，醉于算法却不得精进，随之大二开了一门数据结构的课程，当时不觉得多么重要，现在每每不得解，总得拿出《数据结构》一本寻解！当时课程用的《数据结构》是【严蔚敏、吴伟民】版，感觉是一本不可多得的好教材！PS: 只有分析待处理对象的特性以及各处理对象之间存在的关系，才能写得一手好码！数据结构定义怎么来定义数据结构？其实至今也没有一个被公认的定义，各有所见，各有所解！目前通用的定义：指相互之间存在一种或多种特定关系的数据元素的集合基本结构根据元素之间关系的不同特性，通常可将数据结构分为以下4种基本结构..." } ]
